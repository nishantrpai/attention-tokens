{"version":3,"file":"contentScript.js","mappings":";;;;;;AAAa;;;AAGb;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,MAAM;AACN;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,gCAAgC,gCAAgC;AAChE;AACA,OAAO;AACP;AACA,wCAAwC,qBAAqB;AAC7D,0CAA0C,kBAAkB;AAC5D;AACA,IAAI;AACJ;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA","sources":["webpack://attention-tokens/./src/contentScript.js"],"sourcesContent":["'use strict';\n\n\n// get weekly attenion token data\nlet attentionUsage;\n\nchrome.storage.sync.get('attentionUsage', function (data) {\n  attentionUsage = data.attentionUsage || {\n    total: 0,\n    weekly: {\n      0: 0,\n      1: 0,\n      2: 0,\n      3: 0,\n      4: 0,\n      5: 0,\n      6: 0\n    }\n  };\n\n  // Now you can use attentionUsage object here\n  console.log(attentionUsage);\n});\n\n\nlet previousVisibleText = '';\nlet previousVisibleImages = [];\nlet currentTokensUsed = 0;\n\nfunction isElementInViewport(el) {\n  const rect = el.getBoundingClientRect();\n  return (\n    rect.top >= 0 &&\n    rect.left >= 0 &&\n    rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n    rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n  );\n}\n\nfunction getVisibleText() {\n  const isVisible = (elem) => {\n    const style = window.getComputedStyle(elem);\n    return style.display !== 'none' && style.visibility !== 'hidden' && elem.offsetParent !== null;\n  };\n\n  const getTextNodes = (elem) => {\n    let textNodes = [];\n    if (elem.nodeType === Node.TEXT_NODE) {\n      textNodes.push(elem);\n    } else {\n      for (let child of elem.childNodes) {\n        textNodes = textNodes.concat(getTextNodes(child));\n      }\n    }\n    return textNodes;\n  };\n\n  const body = document.body;\n  const allTextNodes = getTextNodes(body);\n  const visibleTextNodes = allTextNodes.filter(node => isVisible(node.parentElement) && isElementInViewport(node.parentElement));\n  const visibleText = visibleTextNodes.map(node => node.textContent.trim()).filter(text => text.length > 0).join(' ');\n  return visibleText;\n}\n\nfunction getNewVisibleText() {\n  const currentVisibleText = getVisibleText();\n  const newText = currentVisibleText.replace(previousVisibleText, '').trim();\n  previousVisibleText = currentVisibleText;\n  return newText;\n}\n\nfunction updateVisibleText(mutationList, observer) {\n  try {\n    const visibleText = getNewVisibleText();\n    const visibleImages = logNewVisibleImages();\n    visibleImages.forEach(img => {\n      currentTokensUsed += 3 * (img.width * img.height)\n      console.log('token from image', 3 * (img.width * img.height))\n    })\n    currentTokensUsed += visibleText.length / 4;\n      attentionUsage.total += currentTokensUsed || 0;\n      attentionUsage.weekly[new Date().getDay()] = attentionUsage.total;\n      chrome.storage.sync.set({ attentionUsage: attentionUsage }, function () {\n        console.log('Attention usage saved');\n      });\n  \n      console.log(`Total tokens used: ${attentionUsage.total}`);\n      console.log(`Current tokens used: ${currentTokensUsed}`);\n  \n  } catch(e) {\n    console.log(e);\n  }\n    \n}\n\nfunction getVisibleImages() {\n  const isVisible = (elem) => {\n    const style = window.getComputedStyle(elem);\n    return style.display !== 'none' && style.visibility !== 'hidden' && elem.offsetParent !== null;\n  };\n\n  const isElementInViewport = (el) => {\n    const rect = el.getBoundingClientRect();\n    return (\n      rect.top >= 0 &&\n      rect.left >= 0 &&\n      rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) &&\n      rect.right <= (window.innerWidth || document.documentElement.clientWidth)\n    );\n  };\n\n  const newVisibleImages = Array.from(document.querySelectorAll('img'))\n    .filter(img => isVisible(img) && isElementInViewport(img))\n    .map(img => ({\n      src: img.src,\n      width: img.width,\n      height: img.height\n    }));\n\n  return newVisibleImages;\n}\n\nfunction getNewVisibleImages() {\n  const currentVisibleImages = getVisibleImages();\n  const newImages = currentVisibleImages.filter(img => !previousVisibleImages.some(prevImg => prevImg.src === img.src));\n  previousVisibleImages = currentVisibleImages;\n  return newImages;\n}\n\nfunction logNewVisibleImages() {\n  const newVisibleImages = getNewVisibleImages();\n  console.log('Newly Visible Images:', newVisibleImages.length);\n  return newVisibleImages;\n}\n\n// Observe changes in the body\nconst observer = new MutationObserver(updateVisibleText);\n\n// Configure the observer\nconst config = {\n  childList: true,\n  subtree: true,\n  characterData: true\n};\n\n// Start observing the body for changes\nobserver.observe(document.body, config);\n\n// Initial call to log the visible text\nupdateVisibleText();\nlogNewVisibleImages();\n"],"names":[],"sourceRoot":""}